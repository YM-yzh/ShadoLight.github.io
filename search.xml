<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[光]]></title>
    <url>%2F%2F2016%2F1006%2Fguang%2F</url>
    <content type="text"><![CDATA[光(guang) [问题] [问题描述] 小 S 对神的高傲感到了厌烦,她把神域改造成了一个微型世界,这个世界有 n 个关键点,有 m 条边连接这 n 个关键点,其中每条边都有一个光的通过时间,小 S 会进行测试,将一道圣光沿某条最短的路径从 1 传播到 n,每条边上的微型生命都想看到圣光,他们想知道至少将这条边的光的通过时间缩短多少才能保证看到圣光(此时他们不会考虑其它边的变化). [输入格式] 第一行两个正整数 n 和 m.接下来 m 行每行三个正整数 u,v,w,表示这条边从 u 指向 v,原先的通过时间为 w. [输出格式] m 行,依次给出每条边的答案,注意缩短的时间必须是整数且缩短后的值必须为正,如果这条边上的人一定见不到圣光则输出-1. [样例] guang.in guang.out 3 3 0 1 3 2 2 1 3 3 -1 2 3 1 [样例解释] 边 u=1,v=3,w=2 就是 1 到 3 的最短路,所以缩短的时间为 0;边 u=1,v=3,w=3 必须把 w 缩短 2 后变成 1 才是 1 到 3 的最短路;边 u=2,v=3,w=1 无论 w 怎么缩短都不会变成 1 到 3 的最短路,所以输出-1. [数据范围] 60%的数据:n≤100;80%的数据:n≤1000;100%的数据:n≤10000,w≤109;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神]]></title>
    <url>%2F%2F2016%2F1006%2Fshen%2F</url>
    <content type="text"><![CDATA[神(shen) [问题] [问题描述] 击败恶魔后,小 S 发现了一片 n*n 的神域,神是高傲的,他们总是斜着站且不希望自己的左右或前方有其它的神,现在小 S 想知道这片神域里最多能存在多少个神.下图是一个示例,S 位置是一个面朝右上的神,S 和 X 的位置不能再放其它的神,注意神一定是斜着的. [输入格式] 第一行一个正整数 T 表示测试数据组数.接下来 T 行每行一个正整数 n. [输出格式] 对每组数据输出一行一个整数表示答案. [样例] shen.in shen.out 1 4 2 [数据范围] 20%的数据:n≤4;40%的数据:n≤5;60%的数据:n≤6;80%的数据:n≤7;100%的数据:T≤10,N≤8. [代码]1234567891011121314151617181920#include "stdio.h"const int AC[8]=&#123;1,4,6,8,11,14,17,20&#125;;int t,n;int main()&#123;#ifndef ONLINE_JUDGE freopen("shen.in","r",stdin); freopen("shen.out","w",stdout);#endif scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); printf("%d\n",AC[n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔]]></title>
    <url>%2F%2F2016%2F1006%2Fmo%2F</url>
    <content type="text"><![CDATA[魔(mo) [问题] [问题描述] 有 n 个恶魔降临了…小 S 决定打击这些恶魔,她的魔法能在一瞬间同时杀死任意数量的恶魔,但是有些恶魔之间存在保护关系,比如恶魔 A 保护恶魔 B,则如果 A 不死则 B 不受伤害,现在小 S 想知道最少需要使用多少次魔法才能杀死所有恶魔,如果不能杀死所有恶魔,输出-1. [输入格式] 第一行两个个正整数 n 和 m 分别表示恶魔数和保护关系对数.接下来 m 行每行两个数 A 和 B 描述一对保护关系. [输出格式] 一行一个整数表示答案. [样例] mo.in mo.out 3 2 2 1 2 3 2 [数据范围] 20%的数据:n≤10;40%的数据:n≤100;60%的数据:n≤1000;80%的数据:n≤10000;100%的数据:n≤100000. [代码]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include "stdio.h"#include "deque"using namespace std;const int N=1e+5 +4;struct Demon&#123; int id; int no;&#125;;int n,m;int De[N];int ans;int ft[N],nt[N],ed[N];bool vis[N];void add(int u,int v,int TNT)&#123; nt[TNT]=ft[u]; ft[u]=TNT; ed[TNT]=v;&#125;bool topo()&#123; deque&lt;Demon&gt; q; for(int i=1;i&lt;=n;i++) if(De[i]==0) q.push_back((Demon)&#123;i,1&#125;); int tot=0; while(q.size()) &#123; Demon t=q.front(); ans=t.no; tot++; q.pop_front(); for(int i=ft[t.id];i;i=nt[i]) &#123; De[ed[i]]--; if(De[ed[i]]==0) q.push_back((Demon)&#123;ed[i],t.no+1&#125;); &#125; &#125; return tot&lt;n;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("mo.in","r",stdin); freopen("mo.out","w",stdout);#endif scanf("%d%d",&amp;n,&amp;m); for(int i=1,a,b;i&lt;=m;i++) &#123; scanf("%d%d",&amp;a,&amp;b); add(a,b,i); De[b]++; &#125; if(topo()) return puts("-1") and false; return printf("%d\n",ans) and false;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶]]></title>
    <url>%2F%2F2016%2F1006%2Fe%2F</url>
    <content type="text"><![CDATA[恶(e) [问题] [问题描述] 有 n 个恶魔就要诞生了,恶魔头子要给每个即将诞生的恶魔取一个名字,恶魔秘书给恶魔头子提供了 n 个字符串供参考,由于每个字符串单词都很长,恶魔头子想到先把单词化简一下,方法是把每个单词尽量取短些的前缀,但所取的前缀不能是其它单词的前缀.这个任务现在就交给你来完成. [输入格式] 第一行一个整数 N,表示单词个数.下面有 N 行,每行一个单词,每个单词的长度不超过 50,且都是由小写字母组成,保证所给单词没有一个单词是另一个单词的前缀. [输出格式] 共 N 行,每行一个单词,是对应上面的 N 个单词化简后的单词. [样例] e.in e.out 3 a abc e efg i ijh [数据范围] 100%的数据:1 ≤N ≤50. [代码]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include "stdio.h"#include "string.h"const int N=54;int n;char name[N][N];char ans[N],tmp[N];bool avail;int main()&#123;#ifndef ONLINE_JUDGE freopen("e.in","r",stdin); freopen("e.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%s",name[i]); for(int i=1;i&lt;=n;i++) &#123; int len=strlen(name[i]); for(int j=1;j&lt;=len;j++) &#123; strcpy(ans,name[i]); ans[j]='\0'; avail=true; for(int k=1;k&lt;=n;k++) &#123; if(k==i) continue; strcpy(tmp,name[k]); tmp[j]='\0'; if(!strcmp(ans,tmp)) &#123; avail=false; break; &#125; &#125; if(avail) &#123; printf("%s\n",ans); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风]]></title>
    <url>%2F%2F2016%2F1005%2Ffeng%2F</url>
    <content type="text"><![CDATA[风(feng) [问题] [问题描述] 起风了,风中飘着很多数字对,小 S 认为,只有满足某种特定关系的数字对才能飘得更远,现在她想知道满足 a+b&lt;=n,且 ab/(a+b)是整数的正整数对(a,b)有多少. [输入格式] 一行一个正整数 n. [输出格式] 一行一个整数表示答案. [样例] feng.in feng.out 21 11 [数据范围] 40%的数据:n≤10^3;60%的数据:n≤10^5;80%的数据:n≤10^7;100%的数据:n≤10^12;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水]]></title>
    <url>%2F%2F2016%2F1005%2Fshui%2F</url>
    <content type="text"><![CDATA[水(shui) [问题] [问题描述] 小 S 有一个水瓶,里面装有一定量的水,由于某些原因,她只记得水瓶里的水在[L,R]区间内,小 S 还有两个水杯,她每次可以往一个杯子里倒任意数量的水(可以不是整数),如果不足则全部倒完,现在她想知道至少需要多少次操作才能保证对于[L,R]中的每个数,操作完成后水瓶里剩的水不超过 1,且两个杯子里水量的差也不超过 1. [输入格式] 第一行一个正整数 T 表示测试数据组数.接下来 T 行每行两个非负整数 L 和 R. [输出格式] 对每组数据输出一行一个整数表示答案. [样例] shui.in shui.out 2 2 3 5 3 8 13 [数据范围] 20%的数据:L≤R≤10;另有 20%的数据:L=R;另有 20%的数据:L=0;100%的数据:T≤10000,L≤R≤10^9.]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地]]></title>
    <url>%2F%2F2016%2F1005%2Fdi%2F</url>
    <content type="text"><![CDATA[地(di) [问题] [问题描述] 地上有一块 n*n 的棋盘,小 S 决定在上面放棋子,使任意两个棋子都不在同一行或同一列或同一斜线,由于小 S 不想思考,她决定逐行且在每行从左往右考虑格子,如果能放棋子就放上棋子,现在她想知道这样会放上多少个棋子. [输入格式] 一行一个正整数 n. [输出格式] 一行一个整数表示答案. [样例] di.in di.out 5 5 [数据范围] 40%的数据:n≤1000;60%的数据:n≤20000;80%的数据:n≤30000;100%的数据:n≤40000.]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数]]></title>
    <url>%2F%2F2016%2F1005%2Fshu%2F</url>
    <content type="text"><![CDATA[数(shu) [问题] [问题描述] 将 N 个整数排成一行,每个整数 a[i]的值在(-10000 ≤ a[i] ≤10000).然后从这一行数中进行取数,其规则是:可从这一行中的任何一个位置开始取数,到任何位置结束,但不能不取.找出一种取法,使得取得的和为最大,再找出一种取法,使得取得的和为最小.例如: N=4, 4 个数依次为:13,-6,7,-8 取得和为最大的是:13+(-6)+7=14 取得和为最小的是:-8. [输入格式] 第一行有一个整数 N,第二行为 N 个整数. [输出格式] 输出二行,第一行一个整数表示取得和的最大值,第二行一个整数表示取得和的最小值. [样例] shu.in shu.out 4 14 13 -6 7 -8 -8 [代码] 123456789101112131415161718192021222324252627#include "stdio.h"const int INF=2147483647;int n;int mx=-INF,mn=+INF;int mxs,mns;int main()&#123;#ifndef ONLINE_JUDGE freopen("shu.in","r",stdin); freopen("shu.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int a; scanf("%d",&amp;a); mxs=mxs+a&lt;0?0:mxs+a; mns=mns+a&gt;0?0:mns+a; mx=mx&gt;mxs?mx:mxs; mn=mn&lt;mns?mn:mns; &#125; printf("%d\n%d\n",mx,mn); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文串]]></title>
    <url>%2F%2F2016%2F1005%2Fpalind%2F</url>
    <content type="text"><![CDATA[回文串(palind) [问题] [问题描述] 输入一个只由大小写字母,数字组成的字符串,计算至少添加几个字符才能使得它变成一个回文串. [输入格式] 第一行为正整数t(≤5),表示数据组数;接下来t行,每行一个只由大小写字母和数字组成的字符串,长度不超过5000. [输出格式] 对于每组数据,输出最少添加字符数. [样例] palind.in palind.out 2 2 Ab3bd 2 abcdcda [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041#include "stdio.h"#include "string.h"#include "algorithm"using namespace std;const int N=5004;int t,n;char a[N],b[N];int f[N][N];int main()&#123;#ifndef ONLINE_JUDGE freopen("palind.in","r",stdin); freopen("palind.out","w",stdout);#endif scanf("%d",&amp;t); while(t--) &#123; scanf("%s",a); n=strlen(a); for(int i=1;i&lt;=n;i++) &#123; f[i][0]=0; b[n-i]=a[i-1]; &#125; for(int i=1;i&lt;=n;i++) f[0][i]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; if(a[i-1]==b[j-1]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); &#125; printf("%d\n",n-f[n][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[能量项链]]></title>
    <url>%2F%2F2016%2F1005%2Fenergy%2F</url>
    <content type="text"><![CDATA[能量项链(energy) [问题] [问题描述] 在Mars星球上,每个Mars人都随身佩带着一串能量项链.在项链上有N颗能量珠.能量珠是一颗有头标记与尾标记的珠子,这些标记对应着某个正整数.并且,对于相邻的两颗珠子,前一颗珠子的尾标记一定等于后一颗珠子的头标记.因为只有这样,通过吸盘(吸盘是Mars人吸收能量的一种器官)的作用,这两颗珠子才能聚合成一颗珠子,同时释放出可以被吸盘吸收的能量.如果前一颗能量珠的头标记为m,尾标记为r,后一颗能量珠的头标记为r,尾标记为n,则聚合后释放的能量为(Mars单位),新产生的珠子的头标记为m,尾标记为n.需要时,Mars人就用吸盘夹住相邻的两颗珠子,通过聚合得到能量,直到项链上只剩下一颗珠子为止.显然,不同的聚合顺序得到的总能量是不同的,请你设计一个聚合顺序,使一串项链释放出的总能量最大.例如:设N=4,4颗珠子的头标记与尾标记依次为(2,3) (3,5) (5,10) (10,2).我们用记号⊕表示两颗珠子的聚合操作,(j⊕k)表示第j,k两颗珠子聚合后所释放的能量.则第4,1两颗珠子聚合后释放的能量为:(4⊕1)=1023=60.这一串项链可以得到最优值的一个聚合顺序所释放的总能量为((4⊕1)⊕2)⊕3)=1023+1035+10510=710. [输入格式] 第一行是一个正整数N(4≤N≤100),表示项链上珠子的个数.第二行是N个用空格隔开的正整数,所有的数均不超过1000,第i个数为第i颗珠子的头标记(1≤i≤N),当i&lt;N时,第i颗珠子的尾标记应该等于第i+1颗珠子的头标记.第N颗珠子的尾标记应该等于第1颗珠子的头标记.至于珠子的顺序,你可以这样确定:将项链放到桌面上,不要出现交叉,随意指定第一颗珠子,然后按顺时针方向确定其他珠子的顺序. [输出格式] 只有一个正整数E(E≤2.1*109),为一个最优聚合顺序所释放的总能量. [样例] energy.in energy.out 4 710 2 3 5 10 [代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243#include "stdio.h"#include "string.h"#include "iostream"using namespace std;const int N=104;const int INF=2147483647;int n,ans;int a[2*N];int f[N][N];int main()&#123;#ifndef ONLINE_JUDGE freopen("energy.in","r",stdin); freopen("energy.out","w",stdout);#endif cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; a[i]; a[n+i]=a[i]; &#125; a[2*n+1]=a[1]; for(int ai=1;ai&lt;=n;ai++) &#123; memset(f,0,sizeof(f)); for(int l=2;l&lt;=n;l++) &#123; for(int i=1;i&lt;=n-l+1;i++) &#123; int j=i+l-1; f[i][j]=-INF; for(int k=i;k&lt;j;k++) f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+a[i+ai]*a[k+ai+1]*a[j+ai+1]); &#125; &#125; ans=max(ans,f[1][n]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石子合并]]></title>
    <url>%2F%2F2016%2F1005%2Fstones%2F</url>
    <content type="text"><![CDATA[石子合并(stones) [问题] [问题描述] 有N(≤200)堆石子排成一排,每堆石子有一定的数量.现要将N堆石子合并成为一堆.合并的过程只能每次将相邻的两堆石子堆成一堆,每次合并花费的代价为这两堆石子的和,经过N-1次合并后成为一堆.求出总的代价最小值. [输入格式] 第一行为正整数t(≤5),表示数据组数;每组数据中,第一行为正整数n(≤200),表示石子总数,第二行为以空格隔开的n个正整数ai(≤1000),分别表示每堆石子的个数. [输出格式] 对于每组数据,输出最小总代价. [样例] stones.in stones.out 2 9 3 239 1 2 3 7 13 7 8 16 21 4 18 [代码] 123456789101112131415161718192021222324252627282930313233343536373839404142#include "stdio.h"#include "string.h"#include "iostream"using namespace std;const int N=204;const int INF=2147483647;int t,n;int a[N],s[N];int f[N][N];int main()&#123;#ifndef ONLINE_JUDGE freopen("stones.in","r",stdin); freopen("stones.out","w",stdout);#endif scanf("%d",&amp;t); while(t--) &#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; a[i]; s[i]=s[i-1]+a[i]; &#125; memset(f,0,sizeof(f)); for(int l=2;l&lt;=n;l++) &#123; for(int i=1;i&lt;=n-l+1;i++) &#123; int j=i+l-1; f[i][j]=INF; for(int k=i;k&lt;j;k++) f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1]); &#125; &#125; cout &lt;&lt; f[1][n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑距离]]></title>
    <url>%2F%2F2016%2F1005%2Fdist%2F</url>
    <content type="text"><![CDATA[编辑距离(dist) [问题] [问题描述] 编辑距离是指两个字串之间,由一个转成另一个所需的最少编辑操作次数,允许的编辑操作包括:将一个字符替换成另一个字符,插入一个字符,删除一个字符.给出两个字符串s1和s2,找出它们之间的编辑距离,即由字符串s1最少经过多少步操作变成字符串s2. [输入格式] 两行字符串,全部由小写字母组成,长度均不超过1000. [输出格式] 只包含一个整数,表示两个字符串的编辑距离. [样例] dist.in dist.out abcde 4 acefg [代码] 1234567891011121314151617181920212223242526272829303132#include "stdio.h"#include "string"#include "iostream"using namespace std;const int N=1004;string a,b;int f[N][N];int main()&#123;#ifndef ONLINE_JUDGE freopen("dist.in","r",stdin); freopen("dist.out","w",stdout);#endif cin &gt;&gt; a &gt;&gt; b; for(int i=1;a[i-1];i++) f[i][0]=i; for(int i=1;b[i-1];i++) f[0][i]=i; for(int i=1;a[i-1];i++) for(int j=1;b[j-1];j++) &#123; int c=1; if(a[i-1]==b[j-1]) c=0; f[i][j]=min(f[i-1][j]+1,min(f[i][j-1]+1,f[i-1][j-1]+c)); &#125; printf("%d\n",f[a.size()][b.size()]); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fib之奇偶性]]></title>
    <url>%2F%2F2016%2F1005%2Ffibs%2F</url>
    <content type="text"><![CDATA[Fib之奇偶性(fibs) [问题] [问题描述] Fibonacci数列大家都已经很熟悉了:f(0)=0,f(1)=1, f(n)=f(n-1)+f(n-2) n≥2.给定正整数n,判别数列第n项的奇偶性. [输入格式] 第一行为正整数t(≤100),表示数据组数;接下来t行,每行一个正整数n(≤108). [输出格式] 输出第n项Fibonacci数列的奇偶性,如果为奇数则请输出“ODD”,否则为“EVEN”. [样例] fibs.in fibs.out 3 ODD 1 ODD 2 EVEN 3 [代码] 12345678910111213141516171819202122#include "stdio.h"int t,n;int main()&#123;#ifndef ONLINE_JUDGE freopen("fibs.in","r",stdin); freopen("fibs.out","w",stdout);#endif scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); n%=3; if(!n) puts("EVEN"); else puts("ODD"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表彰]]></title>
    <url>%2F%2F2016%2F1004%2Fcommend%2F</url>
    <content type="text"><![CDATA[表彰(commend) [问题] [问题描述] 轰炸取得了圆满成功,YJC 决定对飞行员们进行表彰,并选出一名飞行王者.一共有m 名飞行员参加了轰炸,C 国一共有 n 个飞行大队,第 i 个飞行大队认为第 j 个飞行员应该成为飞行王者的人数为 ai,j.对于每一个飞行大队,在这个大队得票最高的飞行员叫做这个大队选择的飞行王者,如果有多个取编号最小的那一个.被最多大队选择的飞行员就是飞行王者,同样如果有多个取编号最小的那一个.现在 YJC 想知道,飞行王者究竟是几号飞行员? [输入格式] 第一行包含两个整数 n 和 m,表示飞行大队的个数和飞行员的个数.接下来 n 行每行包含 m 个整数,第(i+1)行第 j 个整数 ai,j 表示第 i 个飞行大队认为第 j个飞行员应该成为飞行王者的人数. [输出格式] 一行,包含一个整数,表示飞行王者是几号飞行员. [样例] commend.in commend.out 2 2 1 2 2 1 2 [样例解释] 在 1 大队,飞行员 1 得到 2 票,飞行员 2 同样得到 2 票,但飞行员 1 编号小,所以 1大队选择飞行员 1 成为飞行王者.在 2 大队,飞行员 1 得到 1 票,飞行员 2 得到 2 票,所以 2 大队选择飞行员 2 成为飞行王者.飞行员 1 被 1 个大队选择,飞行员 2 同样被 1 个大队选择,但飞行员 1 编号小,所以飞行员 1 成为飞行王者. [数据说明] 对于 100%的数据,满足 2≤n,m≤50,0≤ai,j≤109. [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include "stdio.h"#include "iostream"#include "algorithm"using namespace std;const int N=54;int n,m;int a[N][N],bin[N];int mx,mxi;int main()&#123;#ifndef ONLINE_JUDGE freopen("commend.in","r",stdin); freopen("commend.out","w",stdout);#endif scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; mx=mxi=0; for(int j=1;j&lt;=m;j++) &#123; scanf("%d",&amp;a[i][j]); if(a[i][j]&gt;mx) &#123; mx=a[i][j]; mxi=j; &#125; &#125; bin[mxi]++; &#125; mx=mxi=0; for(int i=1;i&lt;=n;i++) &#123; if(bin[i]&gt;mx) &#123; mx=bin[i]; mxi=i; &#125; &#125; printf("%d\n",mxi); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轰炸]]></title>
    <url>%2F%2F2016%2F1004%2Fbomb%2F</url>
    <content type="text"><![CDATA[轰炸(bomb) [问题] [问题描述] C 国和 W 国爆发了战争!YJC 决定对 W 国的 n 个城市进行轰炸.每个城市都有一个重要度 ai.设 xi=重要度大于 ai的城市数+1,那么第 i 个城市就是第 xi个被轰炸的城市.显然这样能保证重要度大的城市先被轰炸,重要度相同的城市同时被轰炸.现在 YJC 想知道,对于每一个 i,xi等于多少? [输入格式] 第一行包含一个整数 n,表示城市个数.第二行包含 n 个整数,第 i 个整数 ai表示第 i 个城市的重要度. [输出格式] 一行,包含 n 个整数,第 i 个整数 xi表示第 i 个城市是第几个被轰炸的城市. [样例] bomb.in bomb.out 5 1 3 1 3 3 3 1 3 1 1 [数据说明] 对于 100%的数据,满足 1≤n≤2000,1≤ai≤109. [代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include "stdio.h"#include "iostream"#include "algorithm"using namespace std;const int N=2004;const int INF=2147483647;struct City&#123; int id,ip; int x;&#125;a[N];int n;bool operator &lt; (City a,City b)&#123; return a.ip&gt;b.ip;&#125;bool operator &gt; (City a,City b)&#123; return a.id&lt;b.id;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("bomb.in","r",stdin); freopen("bomb.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i].ip); a[i].id=i; &#125; sort(a+1,a+1+n,less&lt;City&gt;()); int cnt=0; a[0].ip=-INF; for(int i=1;i&lt;=n;i++) &#123; if(a[i].ip!=a[i-1].ip) cnt=i; a[i].x=cnt; &#125; sort(a+1,a+1+n,greater&lt;City&gt;()); for(int i=1;i&lt;=n;i++) printf("%d ",a[i].x); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论]]></title>
    <url>%2F%2Fgraph%2F</url>
    <content type="text"><![CDATA[图论 存储 邻接矩阵12345// 从u到v有一条权值为w的边void add(int u,int v,int w)&#123; G[a][b]=c;&#125; 邻接表123456789// 从u到v有一条权值为w的边void add(int u,int v,int w)&#123; tnt++; weight[tnt]=a; edge[tnt]=j; next[tnt]=head[i]; head[i]=tnt;&#125; 遍历&lt;!– 深度优先 1234void DFS()&#123;&#125; 广度优先 `c++void BFS(){ }` –&gt;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>snippets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F%2Fquickpower%2F</url>
    <content type="text"><![CDATA[ab mod c 12345678910111213int QuickPower(int a,int b,int c)&#123; int cnt=1; a=a%c; while(b&gt;0) &#123; if(b&amp;1) cnt=(cnt*a)%c; b/=2; a=(a*a)%c; &#125; return cnt;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>snippets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列]]></title>
    <url>%2F%2F2016%2F1003%2Fseq%2F</url>
    <content type="text"><![CDATA[序列(seq) [问题] [描述] 我们按以下方式产生序列:1, 开始时序列是: “O” ;2, 每一次变化把序列中的 “O” 变成 “OI” ,”I” 变成 “O”.经过无限次变化,我们得到序列”OIOOIOIOOIOOIOIOOIO….”.总共有 Q个询问,每次询问为:在区间[a,b]之间有多少个”O”.请写一个程序回答Q个询问 [输入格式] 第一行为一个整数Q;接下来有Q行,每行两个数用空格隔开的整数a, b. [输出格式] 共Q行,每行一个回答. [样例] seq.in seq.out 1 4 2 8 [数据范围] 100%的数据: 1≤Q≤5000,1≤a≤b&lt;2^63. [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041#include "stdio.h"const int N=92;int n;long long x[N+4],y[N+4];long long find(long long a)&#123; int i; for(i=1;i&lt;=N;i++) if(x[i]&gt;=a) break; if(a==x[i]) return y[i]; return y[i-1]+find(a-x[i-1]);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("seq.in","r",stdin); freopen("seq.out","w",stdout);#endif x[1]=1;x[2]=2; y[1]=y[2]=1; for(int i=3;i&lt;=N;i++) &#123; x[i]=x[i-1]+x[i-2]; y[i]=y[i-1]+y[i-2]; &#125; scanf("%d",&amp;n); while(n--) &#123; long long a,b; scanf("%lld%lld",&amp;a,&amp;b); long long ans=find(b)-find(a-1); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际象棋]]></title>
    <url>%2F%2F2016%2F1003%2Fchess%2F</url>
    <content type="text"><![CDATA[国际象棋(chess) [问题] [问题描述] YJC 想学习国际象棋,但他连个子怎么走都不会.所以他决定练习怎么走子.YJC 有一块 n*m 的棋盘,他在上面摆了若干个皇后,皇后可以走到同一行,同一列,同一条对角线上的任意一个格子.现在他想知道:有多少个格子满足上面有皇后或者可以被某个皇后走到? [输入格式] 第一行包含两个整数 n 和 m,表示棋盘的行数和列数.接下来 n 行每行包含 m 个字符,第(i+1)行第 j 个字符如果是’.’表示上面没有放皇后,如果是’X’表示上面放了皇后. [输出格式] 一行,包含一个整数,表示有多少个格子满足上面有皇后或者可以被某个皇后走到. [样例] chess.in chess.out 2 2 4 .X X. [数据说明] 对于 100%的数据,满足 2≤n,m≤50. [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include "stdio.h"const int N=54;int n,m;bool map[N][N];int tot;int main()&#123;#ifndef ONLINE_JUDGE freopen("chess.in","r",stdin); freopen("chess.out","w",stdout);#endif scanf("%d%d\n",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; char c=getchar(); if(c=='X') &#123; for(int jj=1;jj&lt;=m;jj++) map[i][jj]=true; for(int ii=1;ii&lt;=n;ii++) map[ii][j]=true; for(int ii=i,jj=j;ii&gt;=1 and jj&gt;=1;ii--,jj--) map[ii][jj]=true; for(int ii=i,jj=j;ii&lt;=n and jj&lt;=m;ii++,jj++) map[ii][jj]=true; for(int ii=i,jj=j;ii&gt;=1 and jj&lt;=m;ii--,jj++) map[ii][jj]=true; for(int ii=i,jj=j;ii&lt;=n and jj&gt;=1;ii++,jj--) map[ii][jj]=true; &#125; &#125; getchar(); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) tot+=map[i][j]; printf("%d\n",tot); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[幂]]></title>
    <url>%2F%2F2016%2F1003%2Fpower%2F</url>
    <content type="text"><![CDATA[幂(power) [问题] [问题描述] YJC 想学习幂级数,但他连幂是什么都不知道.所以他想向你请教:在[L,R]中有多少个数是 n 的整数次幂? [输入格式] 第一行包含三个整数 L,R 和 n,意思如题所示. [输出格式] 一行,包含一个整数,表示在[L,R]中有多少个数是 n 的整数次幂. [样例] power.in power.out 1 10 2 4 [数据说明] 对于 100%的数据,满足 1≤L≤R≤109,2≤n≤109. [代码] 12345678910111213141516171819202122#include "stdio.h"int l,r,tot;long long cnt=1,n;int main()&#123;#ifndef ONLINE_JUDGE freopen("power.in","r",stdin); freopen("power.out","w",stdout);#endif scanf("%d%d%lld",&amp;l,&amp;r,&amp;n); while(cnt&lt;l) cnt*=n; while(cnt&lt;=r) &#123; tot++; cnt*=n; &#125; printf("%d\n",tot); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奶酪(cheese)]]></title>
    <url>%2F%2F2016%2F1003%2Fcheese%2F</url>
    <content type="text"><![CDATA[奶酪(cheese) 总时间限制: 100ms | 内存限制: 65536kB [问题] [描述] 阿尔吉侬是一只聪明又慵懒的小白鼠,它最擅长的就是走各种各样的迷宫.今天它要挑战一个非常大的迷宫,研究员们为了鼓励阿尔吉侬尽快到达终点,就在终点放了一块阿尔吉侬最喜欢的奶酪.现在研究员们想知道,如果阿尔吉侬足够聪明,它最少需要多少时间就能吃到奶酪.迷宫用一个R×C的字符矩阵来表示.字符S表示阿尔吉侬所在的位置,字符E表示奶酪所在的位置,字符#表示墙壁,字符.表示可以通行.阿尔吉侬在1个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置,但不能走出地图边界. [输入格式] 第一行包含了两个用空格分开的正整数R和C(2 &lt;= R, C &lt;= 200),表示地图是一个R×C的矩阵.接下来的R行描述了地图的具体内容,每一行包含了C个字符.字符含义如题目描述中所述.保证有且仅有一个S和E. [输出格式] 对于每一组数据,输出阿尔吉侬吃到奶酪的最少单位时间.若阿尔吉侬无法吃到奶酪,则输出“oop!”(只输出引号里面的内容,不输出引号).每组数据的输出结果占一行. [样例] cheese1.in cheese1.out 3 4 5 .S.. ###. ..E. cheese2.in cheese2.out 3 4 1 .S.. .E.. …. cheese3.in cheese3.out 3 4 oop! .S.. #### ..E. [代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include "deque"#include "iostream"#include "algorithm"using namespace std;const int N=204;const int X[4]=&#123; 0, 0, 1,-1&#125;;const int Y[4]=&#123; 1,-1, 0, 0&#125;;struct XOY&#123; int x,y; int s;&#125;b,e;int n,m;bool a[N][N],v[N][N];deque&lt;XOY&gt; q;void BFS(XOY x)&#123; q.push_back(x); while(q.size()) &#123; XOY o=q.front(); q.pop_front(); for(int i=0;i&lt;4;i++) &#123; int xx=o.x+X[i],yy=o.y+Y[i]; if(xx&lt;1 or xx&gt;n or yy&lt;1 or yy&gt;m) continue; if(v[xx][yy] or a[xx][yy]) continue; v[xx][yy]=true; if(xx==e.x and yy==e.y) &#123; cout &lt;&lt; o.s+1 &lt;&lt; endl; return ; &#125; q.push_back((XOY)&#123;xx,yy,o.s+1&#125;); &#125; &#125; puts("oop!");&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; char c; cin &gt;&gt; c; if(c=='S') b.x=i,b.y=j; if(c=='E') e.x=i,e.y=j; a[i][j]=(c=='#'); &#125; &#125; BFS(b); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赌徒]]></title>
    <url>%2F%2F2016%2F1002%2Fgambler%2F</url>
    <content type="text"><![CDATA[赌徒(gambler) [问题] [描述] 有N个赌徒,手里各自有自己的筹码.在赌博时,他们能向周围的赌徒借钱,所以他们的筹码可能是负的,但筹码都一定是整数.当结束赌博时,N个赌徒当中,筹码刚是另外3个人筹码的总和的赌徒为胜者.如果有多个符合条件的赌徒,选择筹码最大的那个人为胜者.例如 5个赌徒,结束赌博时各有 2,3,5,7,12,则他们中的胜者是持有12的人,因为 12=2+3+7. [输入格式] 第一行为一个整数n,表示有n个赌徒.接下去n行,每行一个整数x表示赌博结束时,每个赌徒手中的筹码. [输出格式] 仅一个整数表示赌博结束时,胜者手中的筹码数.如果没有胜者则输出“no solution”. [样例] gambler.in gambler.out 5 12 235712 [数据范围] 50%的数据满足:1≤n≤100;100%的数据满足:1≤n≤1000,-10^8≤x≤10^8. [代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include "stdio.h"#include "algorithm"using namespace std;const int N=1004;const int MOD=4544443;struct List&#123; int s; int a,b; int n;&#125;l[N*N];int n,li;int a[N],tot[MOD];inline int ab(int x)&#123; return x&lt;0?-x:x;&#125;void add(int a,int b,int s)&#123; l[++li].s=s;l[li].a=a;l[li].b=b; l[li].n=tot[ab(s)%MOD]; tot[ab(s)%MOD]=li;&#125;bool op(int a,int b,int s)&#123; for(int i=tot[ab(s)%MOD];i&gt;=1;i=l[i].n) if(l[i].s==s and l[i].a!=a and l[i].b!=b and l[i].a!=b and l[i].b!=a) return true; return false;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("gambler.in","r",stdin); freopen("gambler.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) add(i,j,a[i]+a[j]); bool f=false; for(int i=n;i&gt;=1;i--) &#123; for(int j=1;j&lt;=n;j++) if(i!=j and op(i,j,a[i]-a[j])) &#123; printf("%d\n",a[i]); f=true; break; &#125; if(f) break; &#125; if(!f) puts("no solution"); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购物]]></title>
    <url>%2F%2F2016%2F1002%2Fshopping%2F</url>
    <content type="text"><![CDATA[购物(shopping) [问题] [描述] 今天,金鹰新城市开业了,小Y也去凑热闹.他看到促销广告:商品大减价.于是他很高兴地拿着篮子购物去了.已知商场有n种商品.每种商品的重量为w千克,价格为v,价值为t.此种商品有h件. 注意:此商场有一个奇怪的规定.每种物品要么不买,要么买1件或h件.小Y带了y元且他最多能扛x千克的物品.请帮小Y最多能获得的价值(不允许抢劫). [输入格式] 第一行有3个用空格隔开的整数n,x和y.接下来的n行,每行有4个数据,分别为w,v,t和h. [输出格式] 仅有一行,表示小Y能获得的最大价值. [样例] shopping.in shopping.out 2 8 10 17 5 3 7 13 7 10 1 [数据范围] 100%的数据满足:0≤n≤300,0≤x≤100,0≤y≤100,0≤h≤10. [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include "stdio.h"const int N=304;struct Item&#123; int w,v,t,h;&#125;a[N];int n,W,V;int f[N][N];inline int mx(int x,int y)&#123; return x&gt;y?x:y;&#125;int Choose(int i,int j,int k)&#123; int x=f[j-a[i].w][k-a[i].v]+a[i].t; int y=0; if(j&gt;=a[i].w*a[i].h and k&gt;=a[i].v*a[i].h) y=f[j-a[i].w*a[i].h][k-a[i].v*a[i].h]+a[i].t*a[i].h; return mx(x,y);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("shopping.in","r",stdin); freopen("shopping.out","w",stdout);#endif scanf("%d%d%d",&amp;n,&amp;W,&amp;V); for(int i=1;i&lt;=n;i++) scanf("%d%d%d%d",&amp;a[i].w,&amp;a[i].v,&amp;a[i].t,&amp;a[i].h); for(int i=1;i&lt;=n;i++) for(int j=W;j&gt;=a[i].w;j--) for(int k=V;k&gt;=a[i].v;k--) &#123; f[j][k]=mx(f[j][k],Choose(i,j,k)); &#125; printf("%d\n",f[W][V]); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文平方数]]></title>
    <url>%2F%2F2016%2F1002%2Fpalind%2F</url>
    <content type="text"><![CDATA[回文平方数(palind) [问题] [描述] 回文数是指从左向右读和从右向左读都一样的数.如12321就是一个回文数.现在给定一个进制B(B是十进制),输出所有的大于等于1小于等于300且它的平方用B进制表示时是回文数的数.用” A “,”B”……表示10,11等等. [输入格式] 共一行,一个单独的整数B(B用十进制表示). [输出格式] 每行两个数字(都是B进制数表示),第二个数是第一个数的平方,且第二个数是回文数. [样例] palind.in palind.out 10 1 1 2 4 3 9 11 121 22 484 26 676 101 10201 111 12321 121 14641 202 40804 212 44944 264 69696 [数据范围] 100%的数据:2≤B≤20. [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include "stdio.h"#include "string"#include "iostream"#include "algorithm"using namespace std;int b;bool op(string x)&#123; string y=x; reverse(y.begin(),y.end()); return (x==y);&#125;char change(int x)&#123; if(x&gt;=10) return x-10+'A'; return x+'0';&#125;string toB(int x)&#123; string y; while(x) &#123; y.insert(y.end(),change(x%b)); x/=b; &#125; reverse(y.begin(),y.end()); return y;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("ps.in","r",stdin); freopen("ps.out","w",stdout);#endif scanf("%d",&amp;b); for(int i=1;i&lt;=300;i++) &#123; string x=toB(i); string y=toB(i*i); if(op(y)) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解压]]></title>
    <url>%2F%2F2016%2F1002%2Funzip%2F</url>
    <content type="text"><![CDATA[解压(unzip) [问题] [描述] 读取一些被压缩的数据,进行解压,再根据题目要求将结果输出至屏幕. [输入格式] 第一行为一个正整数k,指明以下的数据分为k段.第二行是k段压缩数据串,每个段有两种格式(数之间用一个空格分隔):如果每段第1个数n为正,则该段只有两个数,其解压操作是将该段的第2个数重复n次;如果每段第1个数n为负数,则该段有|n|+1个数,其解压操作是重复该段从第2个数开始的|n|个数一次.(注:|n|表示取n的绝对值) [输出格式] 经解压后得到的整数串上所有数字之和. [样例] unzip.in unzip.out 5 31 3 2 -5 0 1 2 3 4 5 1 5 0 -4 4 3 2 1 [样例] Explan 经解压后得到的整数串 2 2 2 0 1 2 3 4 1 1 1 1 1 0 0 0 0 0 4 3 2 1 [数据范围] 100%的数据:k≤10,|n|≤10,其余的数≤10000. [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include "stdio.h"int t,n,a;int tot;int ans(int x)&#123; int cnt=0; while(x&gt;0) &#123; cnt+=x%10; x/=10; &#125; return cnt;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("unzip.in","r",stdin); freopen("unzip.out","w",stdout);#endif scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); if(n&gt;0) &#123; scanf("%d",&amp;a); tot+=ans(a)\*n; &#125; else &#123; n=-n; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a); tot+=ans(a); &#125; &#125; &#125; printf("%d\n",tot); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加一]]></title>
    <url>%2F%2F2016%2F1002%2Faddone%2F</url>
    <content type="text"><![CDATA[加一(addone) [问题] [问题描述] 你的任务是很简单,给你一个非负整数 N,输出 N+1.唯一的复杂之处在于给出的整数是一个 2~36 进制(包括边界)中一个未知进制的整数.(大家知道的,从 10 开始的数字分别用 A,B,C,……来表示)因此,你的程序必须按字典序递增输出所有可能的结果. [输入格式] 一行,包含一个由数字 0 至 9 与大写字母 A 至 Z 组成的整数 N,数据保证没有前导零. [输出格式] 输出所有的可能结果,每个结果占一行. [样例] addone1.in addone1.out 32 33 addone2.in addone2.out 9 10 A [样例 2 说明] 9 是 10 进制则加 1 答案为 10,为大于 10 进制时则加 1 答案为 A. [数据范围] N 包含 1 至 200 位数字. [代码] 1234567891011121314#include "stdio.h"int n;int main()&#123;#ifndef ONLINE_JUDGE freopen("addone.in","r",stdin); freopen("addone.out","w",stdout);#endif scanf("%d",&amp;n); printf("%d\n",n+1); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苟]]></title>
    <url>%2F%2F2016%2F1002%2Fgou%2F</url>
    <content type="text"><![CDATA[苟(gou) [问题] [问题描述] 苟先生有一个字符串,不过他的朋友富先生对他的字符串做了一些小手脚,不仅打乱了顺序而且还把一些字符变成了*,而且这个字符串混进了一大堆字符串中,苟先生想知道哪些可能是他的字符串. [输入格式] 第一行一个整数 n 表示字符串长度.第二行一个只含小写字母的长度为 n 的字符串表示苟先生的串.第三行一个整数 m 表示混进的字符串数量.接下来 m 行每行一个长度为 n 的字符串,包含小写字母和*. [输出格式] 输出一行一个 m 位的二进制数,如果第 i 个字符串可能是苟先生的,第 i位就为 1,否则为 0. [样例] gou.in gou.out 3 101 aba 3 aab bb* a** [数据范围] 对于 40%的数据不含*;对于 100%的数据 n,m≤100. [代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include "stdio.h"#include "iostream"#include "algorithm"using namespace std;const int N=104;int n,m;char org[N],str[N];int cnt;bool cmp(char a,char b)&#123; if (a=='*') return false; if (b=='*') return true; return a &lt; b;&#125;bool op(const char *a,const char *b)&#123; int i,j; for(i=0,j=0;i&lt;n;i++) &#123; if(a[i]!=b[j]) &#123; if(cnt) &#123; cnt--; continue; &#125; else return false; &#125; j++; &#125; return true;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("gou.in", "r", stdin); freopen("gou.out", "w", stdout);#endif scanf("%d",&amp;n); scanf("%s",org); sort(org,org+n,cmp); scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; cnt=0; scanf("%s",str); sort(str,str+n,cmp); for(int k=0;k&lt;n;k++) if(str[k]=='*') cnt++; if (op(org,str)) printf("1"); else printf("0"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建二叉树]]></title>
    <url>%2F%2F2016%2F1002%2Ftree%2F</url>
    <content type="text"><![CDATA[构建二叉树(tree) [问题] [问题描述] 树的表示方法很多,可以采用自然界的树形表示法如图,另外也可以采用括号表示法,先将根结点放入一对圆括号中,然后把它的子树按由左往右的顺序放入括号中,而对子树也采用同样的方法处理.同层子树与它的根结点用圆括号扩起来,同层子树之间用逗号格开,最后用闭括号括起来.如图所示的树可以表示成:(1(2(4,5),3))由完全二叉树的定义我们可知,如果知道该完全二叉树的结点个数,则可以构建出一棵确定的完全二叉树,现在输入完全二叉树的结点数 N(N≤2 14 ), 用括号表示法输出这棵树.(默认树的结点名称为树结点的编号) [输入格式] N 完全二叉树的结点个数. [输出格式] N 个结点的完全二叉树的括号表示. [样例] tree.in tree.out 5 (1(2(4,5),3)) [代码] 1234567891011121314151617181920212223242526272829303132333435#include "stdio.h"int n;void DFS(int i)&#123; if(i&gt;n) return ; printf("%d",i); if(i*2&lt;=n) &#123; printf("("); if(i*2&lt;=n) DFS(i*2); if(i*2+1&lt;=n) &#123; printf(","); DFS(i*2+1); &#125; printf(")"); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("tree.in","r",stdin); freopen("tree.out","w",stdout);#endif scanf("%d",&amp;n); printf("("); DFS(1); printf(")"); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵相似]]></title>
    <url>%2F%2F2016%2F1002%2Fmatrix%2F</url>
    <content type="text"><![CDATA[矩阵相似(matrix) [问题] [问题描述] 给出 2 个大小相同的矩阵方阵 A,B,方阵中的元素为 0 或 1.若 A 和 B相似,满足下面条件: A=B –&gt; 输出 0 A 经过顺时针旋转 90°成为 B –&gt; 输出 1 A 经过顺时针旋转 180°成为 B –&gt; 输出 2 A 经过顺时针旋转 270°成为 B –&gt; 输出 3 若 A,B 不相似 –&gt; 输出-1 [输入格式] 第一行为一个整数 n;接下来的 n 行表示 A 矩阵的 01 方阵;再接下来的 n 行表示 B 矩阵的 01 方阵. [输出格式] 一个整数(0,或 1,或 2, 或 3,或-1)即 A,B 相似的结果. [样例] matrix.in matrix.out 4 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 [数据范围] 100%的数据:1≤n≤20 [代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243#include "stdio.h"const int N=24;int n;int A,B,C,R;bool a[N][N],b[N][N];int main()&#123;#ifndef ONLINE_JUDGE freopen("matrix.in","r",stdin); freopen("matrix.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;b[i][j]); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; A+=(a[i][j]==b[j][n+1-i]); B+=(a[i][j]==b[n+1-i][n+1-j]); C+=(a[i][j]==b[n+1-j][i]); R+=(a[i][j]==b[i][j]); &#125; &#125; if(R==n*n) puts("0"); else if(A==n*n) puts("1"); else if(B==n*n) puts("2"); else if(C==n*n) puts("3"); else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冰雹序列]]></title>
    <url>%2F%2F2016%2F1002%2Fhailstone%2F</url>
    <content type="text"><![CDATA[冰雹序列(hailstone) [问题] [题目描述]: 冰雹序列是这样形成的:1,如果N为偶数,则将其除以2;2,如果N为奇数,则将其乘以3在加上1;这个序列最后总是在:4 2 1 循环.所以当N==1,时我们认为序列结束.写一个程序,计算出序列中的最大值. [输入描述]: 第一行给出P(1&lt;= P &lt;= 100,000)表示测试组数.每组数据一行两个整数:第一个是测试组数;第二个数是N (1 &lt;= n &lt;= 100,000),表示序列起始值; [输出描述]: 输出每组测试一行两个整数.第一个数是测试组数;第二个数是这是序列的最大值(不超过int类型). [样例] hailstone.in hailstone.out 4 1 1 1 1 2 16 2 3 3 101248 3 9999 4 100000 4 100000 [代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include "stdio.h"const int N=40000004;int t,n;int f[N];int mx(int a,int b)&#123; return a&gt;b?a:b;&#125;int DFS(int x)&#123; if(x&gt;N) &#123; switch(x&amp;1) &#123; case 0:return mx(x,DFS(x/2)); case 1:return mx(x*3+1,DFS(x*3+1)); &#125; &#125; if(f[x]) return f[x]; if(x==1) return 1; switch(x&amp;1) &#123; case 0:f[x]=mx(x,DFS(x/2));break; case 1:f[x]=mx(x*3+1,DFS(x*3+1));break; &#125; return f[x];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("hailstone.in","r",stdin); freopen("hailstone.out","w",stdout);#endif scanf("%d",&amp;t); for(int ti=1;ti&lt;=t;ti++) &#123; scanf("%\*d%d",&amp;n); printf("%d %d\n",ti,DFS(n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔族密码]]></title>
    <url>%2F%2F2016%2F1002%2Fpassword%2F</url>
    <content type="text"><![CDATA[魔族密码(password) [问题] [描述] 风之子刚走进他的考场,就……花花:当当当当~~偶是魅力女皇——花花!!^^(华丽出场,礼炮,鲜花)风之子:我呕……(杀死人的眼神)快说题目!否则……花花:……咦~~好冷~~我们现在要解决的是魔族的密码问题(自我陶醉:搞不好魔族里面还会有人用密码给我和菜虫写情书咧,哦活活,当然是给我的比较多拉.)魔族现在使用一种新型的密码系统.每一个密码都是一个给定的仅包含小写字母的英文单词表,每个单词至少包含1个字母,至多75个字母.如果在一个由一个词或多个词组成的表中,除了最后一个以外,每个单词都被其后的一个单词所包含,即前一个单词是后一个单词的前缀,则称词表为一个词链.例如下面单词组成了一个词链:iintinteger但下面的单词不组成词链:integerintern现在你要做的就是在一个给定的单词表中取出一些词,组成最长的词链,就是包含单词数最多的词链.将它的单词数统计出来,就得到密码了.风之子:密码就是最长词链所包括的单词数阿……花花:活活活,还有,这些文件的格式是,第一行为单词表中的单词数N(1&lt;=N&lt;=2000),下面每一行有一个单词,按字典顺排列,中间也没有重复的单词咧!!你要提交的文件中只要在第一行输出密码就行啦^^看你长得还不错,给你一个样例吧: [样例] password.in passeord.out 5 4 iintintegerinterninternet [时间限制] 各个测试点1s [代码 ] 123456789101112131415161718192021222324252627282930313233343536373839404142#include "stdio.h"#include "string"#include "iostream"using namespace std;const int N=2004;int n;int f[N],ans;string s[N];bool op(string a,string b)&#123; if(a.size()&gt;b.size()) return false; for(int i=0;a[i];i++) if(a[i]!=b[i]) return false; return true;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("password.in","r",stdin); freopen("password.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) cin &gt;&gt; s[i]; f[1]=1; for(int i=2;i&lt;=n;i++) &#123; f[i]=1; for(int j=i-1;j&gt;=1;j--) if(op(s[j],s[i])) f[i]=max(f[i],f[j]+1); ans=ans&gt;f[i]?ans:f[i]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传球游戏]]></title>
    <url>%2F%2F2016%2F1002%2Fpassball%2F</url>
    <content type="text"><![CDATA[传球游戏(passball) [问题] [题目描述]: 上体育课的时候,小蛮的老师经常带着同学们一起做游戏.这次,老师带着同学们一起做传球游戏.游戏规则是这样的:n个同学站成一个圆圈,其中的一个同学手里拿着一个球,当老师吹哨子时开始传球,每个同学可以把球传自己左右的两个同学中的一个(左右任意),当老师再次吹哨子时,传球停止,此时,拿着球没传出去的那个同学就是败者,要大家表演一个节目.聪明的小蛮提出了一个有趣的问题:有多少种不同的传球方法可以使得从小蛮手里开始传的球,传了m次以后,又回到小蛮手里两种传球方法被视作不同的方法,当且仅当这两种方法中,接到球的同学按接球顺序组成的序列是不同的.比如有三个同学1号,号,3号,并假设小蛮为1号,球传了三次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1,共2种. [输入描述]: 输入共一行,有两个用空格隔开的整数n,m(3&lt;=n&lt;=30,1&lt;=m&lt;=30). [输出描述]: 输出共一行,有一个整数,标示符合题意的方法数. [样例] passball.in passball.out 3 3 2 [代码] 12345678910111213141516171819202122232425262728293031323334#include "stdio.h"#include "string.h"#include "iostream"using namespace std;const int N=34;int n,m;int f[N][N];int DFS(int i,int s)&#123; if(s==0) &#123; if(i==1) return 1; return 0; &#125; if( not (f[i][s]==-1)) return f[i][s]; return f[i][s]=DFS(i==n?1:i+1,s-1)+DFS(i==1?n:i-1,s-1);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("passball.in","r",stdin); freopen("passball.out","w",stdout);#endif memset(f,-1,sizeof(f)); cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; DFS(1,m); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产调度]]></title>
    <url>%2F%2F2016%2F1001%2Fdispatch%2F</url>
    <content type="text"><![CDATA[生产调度(dispatch) [问题] [描述] 某工厂收到了n个产品的订单,这n个产品分别在A,B两个车间加工,并且必须先在A车间加工后才可以到B车间加工.某个产品i在A,B两车间加工的时间分别为Ai,Bi.怎样安排这n个产品的加工顺序,才能使总的加工时间最短.这里所说的加工时间是指:从开始加工第一个产品到最后所有的产品都已在A,B两车间加工完毕的时间. [输入格式] 第一行仅—个数据n,表示产品的数量.接下来n个数据是表示这n个产品在A车间加工各自所要的时间(都是整数).最后的n个数据是表示这n个产品在B车间加工各自所要的时间(都是整数). [输出格式] 第一行一个数据,表示最少的加工时间; [样例] dispatch.in dispatch.out 5 34 3 5 8 7 10 6 2 1 4 9 [数据范围] 100%的数据:1≤n≤1000. [来源] @洛谷 P1248 @Code VS 3008 @TYVJ P3016 @Ye P1702 [代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include "stdio.h"#include "algorithm"using namespace std;const int N=1004;struct Node&#123; int x,id;&#125;m[N];int n;int a[N],b[N],f[N];bool cmp(const Node&amp;a,const Node&amp;b)&#123; return a.x&lt;b.x;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("dispatch.in","r",stdin); freopen("dispatch.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]); for(int i=1;i&lt;=n;i++) m[i]=(Node)&#123;min(a[i],b[i]),i&#125;; sort(m+1,m+1+n,cmp); int p1=1,pn=n; for(int i=1;i&lt;=n;i++) if(m[i].x==a[m[i].id]) f[p1++]=m[i].id; else f[pn--]=m[i].id; int sa=0,sb=0; for(int i=1;i&lt;=n;i++) &#123; sa+=a[f[i]]; sb=max(sa,sb)+b[f[i]]; &#125; printf("%d\n",sb); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>洛谷</tag>
        <tag>Code VS</tag>
        <tag>TYVJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数拆段]]></title>
    <url>%2F%2F2016%2F1001%2Fmult%2F</url>
    <content type="text"><![CDATA[整数拆段(mult) [问题] [描述] 将一个位数为L(4≤L≤10)的自然数N拆成4段,使各段对应的数的乘积最小.你能编一个程序实现吗? [输入格式] 一个自然数N. [输出格式] 一个整数,最小乘积. [样例] mult.in mult.out 321457 2268 [样例] Explan 样例中最小乘积为:3214*27=2268 [数据范围] 100%的数据满足:4≤位数L≤10. [来源] @Ye P1701 [代码] 1234567891011121314151617181920212223242526272829303132333435#include "stdio.h"#include "string"#include "iostream"using namespace std;const long long INF=2147483647;string s;long long mn=INF;void DFS(int b,int d,long long tot,long long cnt)&#123; if(b==s.size()+1 and d==5) &#123; mn=mn&lt;cnt?mn:cnt; return ; &#125; if(b&gt;s.size() or d&gt;4) return ; tot=tot*10+(s[b-1]-'0'); DFS(b+1,d,tot,cnt); DFS(b+1,d+1,0,tot*cnt);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("mult.in","r",stdin); freopen("mult.out","w",stdout);#endif cin &gt;&gt; s; DFS(1,1,0,1); cout &lt;&lt; mn &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码解压]]></title>
    <url>%2F%2F2016%2F1001%2Fpassword%2F</url>
    <content type="text"><![CDATA[密码解压(password) [问题] [描述] 为了保护日益恶劣的地球环境,地球防卫小队决定去求助外星种族的帮助.经过很长时间的努力,小队终于收到了外星生命的回信.但是外星人发过来的却是一串密码.只有解开密码,才能知道外星人给的准确回复.解开密码的第一道工序就是解压缩密码,外星人对于连续的若干个相同的子串“x”会压缩为“[DX]”的形式(D是一个整数且1≤D≤99),比如说字符串“CBCBCBCB”就压缩为“[4CB]”或者“[2[2CB]]”,类似于后面这种压缩之后再压缩的我们称之为二重压缩.如果是“[2[2[2CB]]]”,则是三重.现在我们给你外星人发送的密码,请你对其进行解压缩. [输入格式] 一行,包含一个字符串, 输入只包含数字,大写字母, “[“ 和 “]” . [输出格式] 一行,即一个解压缩后的字符串. [样例] password.in password.out AC[3FUN] ACFUNFUNFUN [数据范围] 50%的数据:解压后的字符串长度在1,000以内,最多只有三重压缩.100%的数据:解压后的字符串长度在20,000以内,最多只有十重压缩. [来源] Ye P1703 [代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include "stdio.h"#include "string"#include "iostream"using namespace std;string s;bool op(int b,int e)&#123; for(int i=b;i&lt;=e;i++) if(s[i]=='[') return true; return false;&#125;void DFS(int b,int e)&#123; if(b&gt;e) return; if(!op(b,e)) for(int i=b;i&lt;=e;i++) cout &lt;&lt; s[i]; else &#123; int i=b; while(s[i]!='[') i++; int j=i+1,t=1; while(t&gt;=1) &#123; if(s[j]=='[') t++; if(s[j]==']') t--; j++; &#125; j--; int n,k; for(n=0,k=i+1;s[k]&gt;='0'&amp;&amp;s[k]&lt;='9';k++) n=n*10+s[k]-'0'; DFS(b,i-1); while(n--) DFS(k,j-1); DFS(j+1,e); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("password.in","r",stdin); freopen("password.out","w",stdout);#endif cin &gt;&gt; s; DFS(0,s.size()-1); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编号]]></title>
    <url>%2F%2F2016%2F1001%2Fnumber%2F</url>
    <content type="text"><![CDATA[编号(number) [问题] [描述] 太郎有N只兔子,现在为了方便识别它们,太郎要给他们编号.兔子们向太郎表达了它们对号码的喜好,每个兔子i想要一个整数,介于1和MaxNumber[i]之间(包括1和MaxNumber[i]).当然,每个兔子的编号是不同的.现在太郎想知道一共有多少种编号的方法.你只用输出答案mod 1000000007即可.如果这是不可能的,就输出0. [输入格式] 第一行是一个整数N(1≤N≤50).第二行N个整数MaxNumber[i] (1≤MaxNumber[i]≤1000). [输出格式] 一个整数 ,表示方案总数 mod 1000000007的值. [样例] number.in number.out 2 35 5 8 [数据范围] 100%的数据:1≤N≤50,1≤MaxNumber[i]≤1000. [来源] @洛谷 P1866 @Ye P1700 [代码] 1234567891011121314151617181920212223242526272829#include "stdio.h"#include "algorithm"using namespace std;const int N=54;const int MOD=1000000007;int n;long long a[N];long long tot=1;int main()&#123;#ifndef ONLINE_JUDGE freopen("number.in","r",stdin); freopen("number.out","w",stdout);#endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++) &#123; tot*=a[i]-i+1; tot%=MOD; &#125; printf("%d\n",tot); return 0;&#125;]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a+b Problem]]></title>
    <url>%2F%2Fa%2Bb_Problem%2F</url>
    <content type="text"><![CDATA[经典 a+b Problem 123456789#include "iostream"using namespace std;int a,b;int main()&#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a+b &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>easy</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI]]></title>
    <url>%2F%2FOI%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[OI Structures 1 基本数据结构 1. 数组 2. 链表, 双向链表 3. 队列, 单调队列, 双端队列 4. 栈, 单调栈 2 中级数据结构 1. 堆 2. 并查集与带权并查集 3. hash 表 - 自然溢出 - 双hash 3 高级数据结构 1. 树状数组 2. 线段树, 线段树合并 3. 平衡树 - Treap 随机平衡二叉树 - Splay 伸展树 - * Scapegoat Tree 替罪羊树 4. 块状数组, 块状链表 5.* 树套树 - 线段树套线段树 - 线段树套平衡树 - * 平衡树套线段树 6.可并堆 - 左偏树 - *配对堆 7. KDtree, 四分树 4 可持久化数据结构 1. 可持久化线段树 - 主席树 2. * 可持久化平衡树 3. * 可持久化块状数组 5 字符串相关算法及数据结构 1. KMP 2. AC 自动机 3. 后缀数组 4. *后缀树 5. *后缀自动机 6. 字典树 Trie 7. manacher 6 图论相关 1. 最小生成树 - Prim - Kruskal 2. 最短路, 次短路, 第K短路 - SPFA - Dijkstra - Floyd 3. 图的连通 - 连通分量 (Tarjan) - 割点, 割边 4. 网络流 - 最大流 - 最小割 - 费用流 - 分数规划 5. 树相关 - 树上倍增, 公共祖先 - 树链剖分 - 树的分治算法(点分治, 边分治, *动态树分治) - 动态树 (LCT, *树分块) - 虚树 - *prufer编码 7. 拓扑排序 8. 欧拉图 9. 二分图 - *KM算法 - 匈牙利算法 7 数学相关 1. (扩展)欧几里得算法, 筛法, 快速幂 - 斐蜀定理 - 更相减损术 2. 欧拉函数与*降幂大法 3. 费马小定理 4. 排列组合 - lucas定理 5. 乘法逆元 6. 矩阵乘法 7. 数学期望与概率 8. 博弈论 - sg函数 - 树上删边游戏 9. *拉格朗日乘子法 10. 中国剩余定理 11. 线性规划与网络流 12. 单纯型线性规划 13. 辛普森积分 14. 模线性方程组 15. 容斥原理与莫比乌斯反演 16. 置换群 17. 快速傅里叶变换 18. *大步小步法(BSGS), 扩展BSGS 8 动态规划 1. 一般, 背包, 状压, 区间, 环形, 树形, 数位动态规划 - 记忆化搜索 - 斯坦纳树 - 背包九讲 2. 斜率优化与* 四边形不等式优化 3. 环 - 外向树上的动态规划 4. *插头动态规划 9 计算几何 1. 计算几何基础 2. 三维计算几何初步 3. *梯形剖分与三角形剖分 4. 旋转卡壳 5. 半平面交 6. pick定理 7. 扫描线 10 搜索相关 1. BFS, DFS 2. A* 算法 3. 迭代加深搜索, 双向广搜 11 特殊算法 1. 莫队算法, *树上莫队 2. 模拟退火 3. 爬山算法 4. 随机增量法 12 其它重要工具与方法 1.模拟与贪心 2. 二分, 三分法(求偏导) 3. 分治, CDQ分治 4. 高精度 5. 离线 6. ST表 13 STL 1. map 2. priority_queue 3. set 4. bitset 5. rope 14 非常见算法 1. *朱刘算法 2. *弦图与区间图 进度 3/oo [+ + + - - - - - - - - - - - - - - - - ……]]]></content>
  </entry>
</search>
